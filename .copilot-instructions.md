# Copilot Instructions for Vue 3 + Pinia + Vite Web Application

## Project Overview

This is a modern Vue 3 client-side web application using Pinia for state management and Vite as the build tool. The application is designed to be fast, reactive, and maintainable with TypeScript support.

## Technology Stack

- **Frontend Framework**: Vue 3 with Composition API
- **State Management**: Pinia
- **Build Tool**: Vite
- **Language**: TypeScript
- **Styling**: CSS Modules or Scoped CSS
- **Package Manager**: npm or pnpm (prefer pnpm for better performance)

## Code Style and Conventions

### Vue Components

- Use `<script setup>` syntax for single-file components
- Prefer Composition API over Options API
- Use TypeScript for type safety
- Follow PascalCase for component names
- Use descriptive, semantic naming

```vue
<template>
  <div class="component-name">
    <!-- Template content -->
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import type { ComponentProps } from './types'

// Props definition
const props = defineProps<ComponentProps>()

// Reactive data
const count = ref(0)

// Computed properties
const doubleCount = computed(() => count.value * 2)

// Methods
const increment = () => {
  count.value++
}
</script>

<style scoped>
.component-name {
  /* Component-specific styles */
}
</style>
```

### Pinia Store Structure

- Use the `defineStore` composition API syntax
- Organize stores by feature/domain
- Use TypeScript interfaces for state typing
- Keep actions pure and testable

```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useFeatureStore = defineStore('feature', () => {
  // State
  const items = ref<Item[]>([])
  const loading = ref(false)

  // Getters
  const itemCount = computed(() => items.value.length)
  const activeItems = computed(() => items.value.filter((item) => item.active))

  // Actions
  const addItem = (item: Item) => {
    items.value.push(item)
  }

  const fetchItems = async () => {
    loading.value = true
    try {
      // API call logic
      const response = await api.getItems()
      items.value = response.data
    } finally {
      loading.value = false
    }
  }

  return {
    // State
    items,
    loading,
    // Getters
    itemCount,
    activeItems,
    // Actions
    addItem,
    fetchItems,
  }
})
```

### File Organization

```
src/
├── components/          # Reusable Vue components
│   ├── ui/             # Base UI components (buttons, inputs, etc.)
│   └── features/       # Feature-specific components
├── stores/             # Pinia stores
├── views/              # Page components/views
├── composables/        # Vue composables
├── utils/              # Utility functions
├── types/              # TypeScript type definitions
├── assets/             # Static assets
└── router/             # Vue Router configuration
```

### Import Conventions

- Use relative imports for better reliability and explicitness
- Avoid path aliases (@/) to prevent configuration issues
- Example: `import BaseButton from '../ui/BaseButton.vue'`
- Example: `import { formatDate } from '../../utils'`

```
src/
├── components/          # Reusable Vue components
│   ├── ui/             # Base UI components (buttons, inputs, etc.)
│   └── features/       # Feature-specific components
├── stores/             # Pinia stores
├── views/              # Page components/views
├── composables/        # Vue composables
├── utils/              # Utility functions
├── types/              # TypeScript type definitions
├── assets/             # Static assets
└── router/             # Vue Router configuration
```

### TypeScript Guidelines

- Use strict TypeScript configuration
- Define interfaces for all data structures
- Use generic types where appropriate
- Prefer `type` for unions and primitives, `interface` for objects

```typescript
// Types
export interface User {
  id: string
  name: string
  email: string
  createdAt: Date
}

export type Status = 'idle' | 'loading' | 'success' | 'error'

// Generic types
export interface ApiResponse<T> {
  data: T
  status: number
  message: string
}
```

### Composables

- Create reusable logic as composables
- Use the `use` prefix for composable functions
- Return reactive references and methods

```typescript
export function useApi<T>(url: string) {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)

  const fetch = async () => {
    loading.value = true
    error.value = null
    try {
      const response = await api.get<T>(url)
      data.value = response.data
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
    } finally {
      loading.value = false
    }
  }

  return { data, loading, error, fetch }
}
```

## Best Practices

### Performance

- Use `v-memo` for expensive list rendering
- Implement virtual scrolling for large datasets
- Use `shallowRef` and `shallowReactive` when appropriate
- Lazy load components with `defineAsyncComponent`

### State Management

- Keep state minimal and normalized
- Use computed properties for derived state
- Implement optimistic updates for better UX
- Handle loading and error states consistently

### Error Handling

- Implement global error handling
- Use try-catch blocks in async operations
- Provide meaningful error messages to users
- Log errors for debugging

### Testing

- Write unit tests for stores and composables
- Use Vue Test Utils for component testing
- Mock external dependencies
- Test user interactions and edge cases

## Development Workflow

1. Start with defining TypeScript interfaces
2. Create Pinia stores for data management
3. Build UI components with proper prop types
4. Implement composables for reusable logic
5. Add proper error handling and loading states
6. Write tests for critical functionality

## Code Quality

- Use ESLint and Prettier for code formatting
- Implement pre-commit hooks with Husky
- Use meaningful commit messages
- Keep components small and focused
- Document complex logic with comments

## Security Considerations

- Sanitize user inputs
- Implement proper validation
- Use HTTPS for all API calls
- Keep dependencies updated
- Follow OWASP guidelines for web security
